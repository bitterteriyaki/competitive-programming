import logging
import subprocess
from collections import defaultdict
from os import devnull
from pathlib import Path

from click import command, option
from rich.logging import RichHandler

log = logging.getLogger(__name__)

normalized_names = {
    "dp": "DP",
    "ds": "Estruturas de Dados",
    "graph": "Grafos",
    "math": "Matemática",
    "dfs": "DFS",
    "bfs": "BFS",
    "ufds": "UFDS",
    "monostack": "Pilha Monótona",
    "monoqueue": "Fila Monótona",
}


def _normalized_name(name: str) -> str:
    if name in normalized_names:
        normalized = normalized_names[name]

        log.debug(f"Normalizing [red]{name}[/] to [red]{normalized}[/]")
        return normalized

    log.debug(f"Could not normalize {name}. Using default normalization.")
    return " ".join(x.capitalize() for x in name.split("_"))


def get_template(name: str) -> str:
    """Get the template file as a string.

    Arguments
    ---------
    name: :class:`str`
        The name of the template file.

    Returns
    -------
    :class:`str`
        The content of the template file

    Raises
    ------
    :class:`FileNotFoundError`
        The template file does not exist.
    """
    log.info(f"Getting the template file: [green]{name}[/]")
    f = Path(name)

    if not f.exists():
        raise FileNotFoundError(f"The template file {name} does not exist.")

    return f.read_text(encoding="utf-8")


def get_sections(path: str) -> dict[str, list[Path]]:
    """Get the sections of the notebook.

    Arguments
    ---------
    path: :class:`str`
        The path to the codes.

    Returns
    -------
    dict[:class:`str`, list[:class:`pathlib.Path`]]
        A dictionary with the sections of the notebook.
    """
    log.info(f"Getting the sections from the path: [red]{path}[/]")

    sections: defaultdict[str, list[Path]] = defaultdict(list)

    codes = Path(path)
    folders = list(codes.iterdir())

    log.debug(f"Found {len(folders)} folders in the path.")

    for folder in folders:
        log.debug(f"Processing the folder: [red]{folder}[/]")

        if not folder.is_dir():
            log.debug(f"The path [red]{folder}[/] is not a directory.")
            continue

        # Hack to insert the folder in the `sections` dictionary,
        # even if it does not contain any files.
        sections[folder.stem]
        files = list(folder.rglob("*.cpp"))

        log.debug(f"Found {len(files)} files in the [red]{folder}[/] folder.")

        for code in files:
            log.debug(f"Processing the file: [green]{code}[/]")
            sections[folder.stem].append(code)

    return dict(sections)


def generate_notebook(template: str, sections: dict[str, list[Path]]) -> str:
    """Generate the notebook.

    Arguments
    ---------
    template: :class:`str`
        The template of the notebook.
    sections: dict[:class:`str`, list[:class:`pathlib.Path`]]
        The sections of the notebook.

    Returns
    -------
    :class:`str`
        The content of the notebook.
    """
    log.info("Generating the notebook.")

    content = ""

    for section, codes in sections.items():
        log.debug(f"Processing the section: [red]{section}[/]")
        log.debug(f"Found {len(codes)} codes in the section.")

        section_name = _normalized_name(section)
        content += f"\\subsection{{{section_name}}}\n"

        for code in codes:
            log.debug(f"Processing the code: [blue]{code}[/]")

            code_name = _normalized_name(code.stem)
            content += f"\\includes{{{code_name}}}{{{code}}}\n"

        content += "\n"

    log.debug("Finished generating the notebook.")
    log.debug("Inserting the content into the template.")

    return template.replace(r"%% INSERT CONTENT HERE %%", content)


def _remove_aux(temporary_name: str) -> None:
    log.info("Removing the auxiliary files generated by LaTeX.")

    for ext in ["aux", "log", "out", "toc", "tex"]:
        f = Path(f"{temporary_name}.{ext}")

        if f.exists():
            f.unlink(missing_ok=True)
            log.debug(f"Removed the file [green]{f}[/]")


@command()
@option("--path", "-p", default="codes", help="Path to the codes.")
@option(
    "--template",
    "-t",
    default="templates/notebook.tex",
    help="The path to the template file.",
)
@option("--output", "-o", default="notebook.pdf", help="The output file.")
@option("--debug", "-d", is_flag=True, help="Enable debug mode.")
def main(path: str, template: str, output: str, debug: bool) -> None:
    """Entrypoint of the script."""
    handler = RichHandler(
        rich_tracebacks=True, omit_repeated_times=False, markup=True
    )

    log.setLevel(logging.DEBUG if debug else logging.INFO)
    log.addHandler(handler)

    log.info("Starting the script.")

    try:
        template = get_template(template)
    except FileNotFoundError:
        log.exception(f"The template file [red]{template}[/] does not exist.")
        return

    sections = get_sections(path)
    notebook = generate_notebook(template, sections)

    temporary_name = "tmp_notebook"
    filename = f"{temporary_name}.tex"

    with Path(filename).open("w", encoding="utf-8") as f:
        f.write(notebook)
        log.info(f"Temporary notebook saved as [green]{filename}[/]")

    cmd = [
        "pdflatex",
        "-interaction=nonstopmode",
        "-halt-on-error",
        filename,
    ]

    log.info("Compiling the notebook into a PDF.")

    with Path(devnull).open("w") as f:
        try:
            # We need to run twice to generate the table of contents.
            # It's weird but it's a LaTeX thing, we can't do anything
            # about it.
            log.debug("First run to generate the table of contents.")
            subprocess.check_call(cmd, stdout=f)

            log.debug("Second run to generate the final PDF file.")
            subprocess.check_call(cmd, stdout=f)
        except Exception:
            log.exception("An error occurred while compiling the notebook.")
            return

    _remove_aux(temporary_name)

    pdf = Path(f"{temporary_name}.pdf")
    pdf.rename(output)

    log.info(f"Notebook saved as [green]{output}[/].")
    log.info("Script finished.")


if __name__ == "__main__":
    main()
